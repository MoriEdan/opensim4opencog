/*
  C#Prolog

  A PREDICATE is a set of CLAUSES with the same principal functor

  A CLAUSE can be a FACT or a RULE

  A RULE consists of a HEAD and a BODY joined by a :-

  A FACT is a Term, a HEAD is a Term, a GOAL is a Term

  a BODY is an expression of terms structured by ','  ';' and parentheses ()

  A QUERY is a list of GOALS

  A GOAL is a Term

  Syntactically, the following is true:

  A QUERY has the same shape as a BODY
*/

SETTINGS

  NameSpace           = 'Prolog'
  CrNoticeNr          = 2
  Prolog              = Y
  CaseSensitive       = Y
  IgnoreEndOfLine     = N
  Preprocessor        = Y
  PreprocessorPrefix  = '#'
  InitIdentifierChars = 'a..zA..ZñçšãåäâàáæëêèéïîìíøõöôòóüûùúýÑÇŠÃÅÄÂÀÁØÆËÊÈÉÏÎÌÍØÕÖÔÒÓÜÛÙÚÝ_'
  IdentifierChars     = 'a..zA..ZñçšãåäâàáæëêèéïîìíøõöôòóüûùúýÑÇŠÃÅÄÂÀÁØÆËÊÈÉÏÎÌÍØÕÖÔÒÓÜÛÙÚÝ0..9_'
  CodeStringChar      = '|'
  CommentStart        = '/*'
  CommentEnd          = '*/'
  SingleComment       = '%'
  StringStart         = ''''
  StringEnd           = ''''
  StringStartAlt      = '"'
  StringEndAlt        = '"'
  StringEscape        = ''''
  EOICheck            = Y

TERMINALS

  Dot               = '.'
  DoubleQuote       = '"'
  Anonymous         = '_'
  CutSym            = '!'
  ImpliesSym        = ':-'
  PromptSym         = '?-'
  DCGArrowSym       = '-->'
  BuiltinAssignSym  = ':=='
  LSqBracket        = '['
  RSqBracket        = ']'
%  LLyBracket        = '(.'  % experimental
%  RLyBracket        = '.)'
  LCuBracket        = '{'
  RCuBracket        = '}'
  VBar              = '|'
  OpSym             = 'op'
%  AtomSym           = 'atom'
  BuiltinSym        = '&builtin'
  QuerySym          = '&query'
  ProgramSym        = '&program'
  ReadingSym        = '&reading'
  EnsureLoaded      = 'ensure_loaded'
  Discontiguous     = 'discontiguous'
  AllDiscontiguous  = 'alldiscontiguous'
  Dynamic           = 'dynamic'
  Persistent        = 'persistent'
  Unpersistent      = 'unpersistent'
  Module            = 'module'
  UndefPredAction   = 'undef_pred_action'
  PrologString      % Double-quoted string

  % TEMP / TESTING
  QMark = '??'


MEMBERS

  private PredicateStorage ps;
  private TermNode queryNode = null;
  public  TermNode QueryNode { get { return queryNode; } }

  public  const string IMPLIES = ":-";
  public  const string DCGIMPL = "-->";
  public  const string ARROW   = "->";
  public  const string DOT     = ".";
  public  const string OP      = "op";
  public  const string ATOM    = "atom";
  public  const string CURL    = "{}";
  public  const string EQ      = "=";
  public  const string EOF     = "end_of_file";
  public  const string COMMA   = ",";
  public  const string SEMI    = ";";

  private Term   readTerm; // result of read (X)
  public  Term   ReadTerm { get { return readTerm; } }
  private bool   inQueryMode;
  public  bool   InQueryMode { get { return inQueryMode; } }

  public enum ParseMode {Builtin, Program, Query, Reading}

  private ParseMode parseMode;

  protected void UserSymbolScanned (ref int terminal, int prevTerminal)
  {
    if (terminal == StringLiteral && symbol.ToString () [0] == '"') terminal = PrologString;
  }


  private void Initialize ()
  {
    ps = (PredicateStorage)parser_arg [0];
    Add1000Operators ();
    terminalTable.Remove ("module");            // will be temporarily set after an initial ':-' only
    terminalTable.Remove ("persistent");        // ...
    terminalTable.Remove ("undef_pred_action"); // ...
  }


  private void Terminate ()
  {
    inQueryMode = true;
  }


  #region Operator handling
  private static bool IsValidOpFormat (string a, bool genXcp) // checks an unquoted sequence
  {
    if (Char.IsLower (a [0]))
    {
      foreach (char c in a.ToCharArray ())
        if (!(Char.IsLetterOrDigit (c) || c == '_'))
        {
          if (genXcp)
            IO.Error (String.Format ("Operator {0} contains illegal character {1}", a, c));
          else
            return false;
        }
    }
    else
      foreach (char d in a.ToCharArray ())
        if (!(Globals.SpecialAtomChars.IndexOf (d) >= 0))
        {
          if (genXcp)
            IO.Error (String.Format ("Operator {0} contains illegal character {1}", a, d));
          else
            return false;
        }

    return true;
  }


  private static void AddPrologOperator (int prec, string type, string name, bool quoted)
  {
    if (prec < 0 || prec > 1200)
      IO.Error (String.Format ("Illegal precedence value {0} for operator {1}", prec, name));

    TermDescr td;

    if (terminalTable.Find (name, out td))
    {
      if (td.OVal is OperatorDescr)
        ((OperatorDescr)td.OVal).Assign (prec, type, quoted);
      else
      {
        td.IVal = Operator;
        td.OVal = new OperatorDescr (prec, type, name, quoted);
      }
    }
    else // new operator
      terminalTable.Add (name, Operator, new OperatorDescr (prec, type, name, quoted));

    //IO.Message ("Operator defined: {0} ({1} {2})", name, prec, type);
  }


  private static void RemovePrologOperator (string type, string name)
  {
    TermDescr td;

    if (terminalTable.Find (name, out td))
    {
      if (td.OVal is OperatorDescr)
        ((OperatorDescr)td.OVal).Assign (-1, type, true);
      else
        IO.Error (String.Format ("Illegal attempt to remove operator {0}", name));

      IO.Message ("Operator deleted: {0} ({1} {2})", name, type);
    }
  }


  public static bool IsOperator (string key)
  {
    return (terminalTable [key] == Operator);
  }


  public static OperatorDescr GetOperatorDescr (string key)
  {
    TermDescr td;

    if (terminalTable.Find (key, out td))
      if (td.OVal is OperatorDescr) return (OperatorDescr)td.OVal;

    return null;
  }


  private static void Add1000Operators ()
  {
    AddPrologOperator (1200, "xfx", IMPLIES, false);
    AddPrologOperator (1200, "fx",  IMPLIES, false);
    AddPrologOperator (1200, "xfx", DCGIMPL, false);
    AddPrologOperator (1150, "xfy", ARROW,   false);
    AddPrologOperator (1100, "xfy", SEMI,    false);
    AddPrologOperator (1000, "xfy", COMMA,   false);
    Set1000Operators (false);
  }

  private static bool is1000OperatorSetting;

  private static void Set1000Operators (bool mode)
  {
    if (mode) // parsed as Operator
    {
      terminalTable [IMPLIES] = Operator;
      terminalTable [DCGIMPL] = Operator;
    }
    else // parsed 'normally'
    {
      terminalTable [IMPLIES] = ImpliesSym;
      terminalTable [DCGIMPL] = DCGArrowSym;
      terminalTable [DOT]     = Dot;
      terminalTable [OP]      = OpSym;
    }
    is1000OperatorSetting = mode;
  }
  #endregion Operator handling


DELEGATES

  SymbolScannedHook  += new SymbolScanned (UserSymbolScanned);


RULES

  PrologCode ->
    |inQueryMode = false;|
    |try {|
    !NL-
    (: BuiltinSym
       |parseMode = ParseMode.Builtin;|
       |Initialize ();|
       Predefineds
    [] ProgramSym % consult
       |parseMode = ParseMode.Program;|
       |Initialize ();|
       Program
    [] ReadingSym % for read (X)
       |parseMode = ParseMode.Reading;|
       ClauseSequence
    [] %QuerySym  % becomes visible in error messages
%       |terminalTable [ATOM] = AtomSym;|
       |Globals.EraseVariables ();|
       |parseMode = ParseMode.Query;|
       |inQueryMode = true;|
       (: |terminalTable [DOT] = Dot;|
          |Set1000Operators (true);|
          Query + |out queryNode|
       [] OperatorDefinition + |true|
          |queryNode = null;|
%       [] PersistentDeclaration
%          |queryNode = null;|
%       [] UnpersistentDeclaration
%          |queryNode = null;|
       :)
       Dot
    :) OPTION
    |} finally {|
    |terminalTable [COMMA] = Operator;|
%    |terminalTable [ATOM]  = Atom;|
    |terminalTable [OP]    = OpSym;|
    |terminalTable [DOT]   = Dot;|
    |Terminate ();|
    |}|
  ---


  Program ->
    ClauseNode SEQUENCE
  ---


  ClauseSequence -> % for read (X), reads clauses (something terminated by a dot) one by one
%|Utils.WriteLine ("Parser: ClauseSequence started");|
    |Monitor.Enter (PrologEngine.TermMonitor);|
%|Utils.WriteLine ("clause: Monitor entered");|
    (: ClauseNode
%|Utils.WriteLine ("clause -- pulsing and entering wait");|
       |Monitor.Pulse (PrologEngine.TermMonitor);|
       |Monitor.Wait (PrologEngine.TermMonitor);|
    :) SEQUENCE
    |readTerm = new Term (EOF);|
%|Utils.WriteLine ("clause: EOF {0}", queryNode);|
    |Monitor.Pulse (PrologEngine.TermMonitor);|
    |Monitor.Exit (PrologEngine.TermMonitor);|
  ---


  ClauseNode ->
    |Term head;|
    |TermNode body = null;|
    |ClauseNode c;|
%    |if (parseMode != ParseMode.Reading && parseMode != ParseMode.Program) Globals.EraseVariables ();|
    |if (parseMode != ParseMode.Reading) Globals.EraseVariables ();|  %JPO: for each ClauseNode ?????????????????
    (: PrologTerm + |out head|
       |if (!head.IsGoal)|
       |  IO.Error ("Illegal predicate head: {0}", head.ToString ());|
       (: ImpliesSym
          Query + |out body|
       [] DCGArrowSym
          |Term t;|
          PrologTerm + |out t|
          |body = t.ToDCG (ref head);|
       :) OPTION
       |c = new ClauseNode (head, body);|
       |if (parseMode == ParseMode.Reading) readTerm = new Term (c).CleanUp (); else ps.AddClause (c);|
    [] PromptSym
       |bool m = inQueryMode;|
       |bool o = is1000OperatorSetting;|
       |int  k = terminalTable [DOT];|
       |try {|
       |parseMode = ParseMode.Query;|
       |inQueryMode = true;|
       |terminalTable [DOT] = Dot;|
       |Set1000Operators (true);|
       Query + |out queryNode|
       |IO.Error ("'?-' querymode in file not yet supported");|
       |} finally {|
       |inQueryMode = m;|
       |terminalTable [DOT] = k;|
       |Set1000Operators (o);|
       |}|
    [] ImpliesSym
       |terminalTable.Add (Persistent, "Persistent", "persistent");|
       |terminalTable.Add (Module, "Module", "module");|
       |terminalTable.Add (UndefPredAction, "UndefPredAction", "undef_pred_action");|
       |try {|
       (: OperatorDefinition + |true|
       [] EnsureLoaded
          (: (: Atom [] StringLiteral :)
             |string fileName = Utils.ExtendedFileName (symbol.ToString ().ToLower (), ".pl");|
             |if (Globals.ConsultedFiles [fileName] == null)|
             |{|
             |  ps.Consult (fileName);|
             |  Globals.ConsultedFiles [fileName] = true;|
             |}|
          :) PACK
       [] Discontiguous
          |Term t;|
          PrologTerm + |out t|
          |ps.SetDiscontiguous (t);|
       [] AllDiscontiguous
          |ps.SetDiscontiguous (true);|
       [] UndefPredAction
          |Term t;|
          PrologTerm + |out t|
          |ps.SetUndefPredAction (t, true);|
       [] Dynamic % dynamic directive is ignored
          |Term t;|
          PrologTerm + |out t|
       [] PersistentDeclaration
%       [] UnpersistentDeclaration
       [] Module % eg.: :-module(dict_n,[]).
          (: |try {|
             |terminalTable [COMMA] = Comma;|
             (: Atom [] StringLiteral :)
             |ps.SetModuleName (symbol.ToString ());|
             Comma
             |} finally {|
             |terminalTable [COMMA] = Operator;|
             |}|
             |Term t;|
             PrologTerm + |out t|
          :) PACK
       [] LSqBracket
          |int lines = 0;|
          |int files = 0;|
          |try {|
          (: (: Atom [] StringLiteral :)
             |string fileName = Utils.FileNameFromSymbol (symbol.ToString (), ".pl");|
             |terminalTable [COMMA] = Operator;|
             |lines += ps.Consult (fileName);|
             |files++;|
             |terminalTable [COMMA] = Comma;|
          :) LIST
          |  if (files > 1) IO.Message ("Grand total is {0} lines", lines);|
          |} finally {|
          |terminalTable [COMMA] = Operator;|
          |}|
          RSqBracket
       :)
       |} finally {|
       |terminalTable.Remove ("module");|
       |terminalTable.Remove ("persistent");|
       |terminalTable.Remove ("undef_pred_action");|
       |}|
    :)
    Dot
  ---


  OperatorDefinition + |bool user| ->
    |string name;|
    |string typeStr;|
    |bool quoted;|
    |try {|
    |terminalTable [COMMA] = Comma;|
    OpSym
    LeftParen
    IntLiteral
    |int prec = symbol.ToInt ();|
    Comma
    Atom
    |typeStr = symbol.ToString ();| % xfy, yfx, etc.
    Comma
    (: LSqBracket
       (: PotentialOpName + |out name, out quoted|
          |AddPrologOperator (prec, typeStr, name, quoted);|
       :) LIST
       RSqBracket
    [] PotentialOpName + |out name, out quoted|
       |AddPrologOperator (prec, typeStr, name, quoted);|
    :)
    RightParen
    |} finally {|
    |terminalTable [COMMA] = Operator;|
    |}|
  ---


  PersistentDeclaration ->
    Persistent
    |Term t;|
    PrologTerm + |out t|
    |ps.SetPersistent (t);|
  ---


  UnpersistentDeclaration ->
    Unpersistent
    |Term t;|
    PrologTerm + |out t|
    |ps.SetUnpersistent (t);|
  ---


  PotentialOpName + |out string name, out bool quoted| ->
    (: StringLiteral
       |name = Utils.MakeAtom (symbol.ToUnquoted ());|
       |quoted = (name [0] == '\'');|
    [] ANYTEXT |IsValidOpFormat (name = symbol.ToString (), true);|
       |quoted = false;|
    :)
  ---


  Predefineds ->
    Predefined SEQUENCE
  ---


  Predefined ->
    |Term     head;|
    |bool     opt  = true;|
    |TermNode body = null;|
    |Globals.EraseVariables ();|
    (: ImpliesSym
       OperatorDefinition + |false|
    [] (: PrologTerm + |out head|
          (: BuiltinAssignSym
             (: Atom [] Operator :)
             |ps.AddPredefined (new ClauseNode (head, new TermNode (symbol.ToString ())));|
             |opt = false;|
          [] ImpliesSym
             Query + |out body|
             |ps.AddPredefined (new ClauseNode (head, body));|
             |opt = false;|
          [] DCGArrowSym
             |Term term;|
             PrologTerm + |out term|
             |body = term.ToDCG (ref head);|
             |ps.AddPredefined (new ClauseNode (head, body));|
             |opt = false;|
          :) OPTION
          |if (opt) ps.AddPredefined (new ClauseNode (head, null));|
       :)
    :)
    Dot
  ---


  Query + |out TermNode body| ->
    |Term t = null;|
    (: PrologTerm + |out t|
       |body = t.ToGoalList ();|
    [] QMark  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TESTING ONLY
       |body = Term.TREEROOT.ToGoalList ();|
       TreeConstruction
    :)
  ---


  TreeConstruction -> % cf. SN1  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TESTING ONLY
    |Term t;|
    PrologTerm + |out t|
    |Console.WriteLine ("Final tree: {0}", t.ToTree ());|
    |Console.WriteLine ("Final term: {0}", t.ToString ());|
  ---


  PrologTerm + |out Term t| ->
    |Term lastInfix = null;| % keep track of infix operators (that may need to be changed into pre- or postfixes)
    |string s;|
    |ArrayList termInfixArr = new ArrayList ();|
    |termInfixArr.Add (null);| % sentinel
    (: (: Operator
          |t = new Term ((OperatorDescr)symbol.OValue);|  // gets infix value (if any) first
       [] (: Atom
             |s = symbol.ToString ();|
          [] StringLiteral % single-quoted
             |s = Utils.UnquoteIfUnnecessary (symbol.ToString ());|
          :)
          |Term[] terms = null;|
          |bool b = is1000OperatorSetting;| % remember setting at entry
          (: |Set1000Operators (true);|
             |terminalTable [DOT] = Atom;| % within parentheses, treat a dot as an atom
             |terminalTable [OP] = Atom;|  % ...
             PrologTerm + |out t|
             |terminalTable [DOT] = Dot;|
             |terminalTable [OP] = OpSym;|
             |terms = t.ArgumentsToTermArray ();|
             |Set1000Operators (b);| % reset to setting at entry
          :) PACK OPTION
          |if (terms == null) t = new Term (s); else t = new Term (s, terms);|
       [] Identifier
          |s = symbol.ToString ();|
          |t = Globals.GetVariable (s);|
          |if (t == null)|
          |{|
          |  t = new NamedVar (s);|
          |  Globals.SetVariable (t, s);| % overwrite if exists
          |}|
       [] Anonymous
          |t = new Term ();|
       [] (: IntLiteral [] RealLiteral :)
          |t = new Term (symbol.ToString (), FType.number);|
       [] List + |out t|
/*
       [] AtomSym
          LeftParen
          MARK
          (: StringLiteral
             |s = Utils.MakeAtom (symbol.ToUnquoted ());|
             |t = new Term (ATOM, new Term (s), OType.noop, 0);|
             RightParen
          [] ANYTEXT
             |if (IsValidOpFormat (s = symbol.ToString (), false))| % it has the format of an operator
             |  t = new Term (ATOM, new Term (s), OType.noop, 0);|
             |else| % check whether it is a term that can be evaluated. TO BE WORKED OUT / TESTED
             |{|
             RightParen
             REDO
             PrologTerm + |out t|
             | t = new Term (ATOM, t, OType.noop, 0);|
             |}|
             RightParen
          :)
*/
       [] DCGBracketList + |out t|
       [] PrologString
          |t = new Term (symbol.ToUnquoted (), FType.text);|
       [] CutSym
          |t = new Cut (0);|
       [] PrologTerm + |out t| PACK
          |t.IsPacked = true;|
       :)
       |termInfixArr.Add (t);|
       |Term.AnalyzeInput (ref termInfixArr, ref lastInfix);|
    :) SEQUENCE
    |termInfixArr.Add (null);| % sentinel
    |Term.AnalyzeInput (ref termInfixArr, ref lastInfix);| % in order to process the last Term
    |t = Term.InfixToPrefix (termInfixArr);|
  ---


  List + |out Term term| ->
    |Term beforeBar;|
    |Term afterBar = null;|
    |ArrayList elements = null;|
    |terminalTable [DOT] = Atom;| % within a list, treat a dot as an atom
    |terminalTable [OP] = Atom;|  % ...
    LSqBracket
    (: PrologTerm + |out beforeBar|
       |elements = beforeBar.ArgumentsToArrayList (false);| % i.e. do not flatten nested packed args
       (: VBar
          PrologTerm + |out afterBar|
       :) OPTION
    :) OPTION
    |terminalTable [DOT] = Dot;|
    |terminalTable [OP] = OpSym;|
    RSqBracket
    |if (afterBar == null) term = Term.NULLLIST; else term = afterBar;|
    |if (elements != null)|
    |  for (int i = elements.Count-1; i >= 0; i--) term = new ListTerm ((Term)elements [i], term);|
  ---


  DCGBracketList + |out Term term| ->
    |Term head;|
    |ArrayList elements = null;|
    LCuBracket
    (: PrologTerm + |out head|
       |elements = head.ArgumentsToArrayList (true);| % i.e. flatten x-->(a,b),c to x-->a,b,c
    :) OPTION
    RCuBracket
    |term = new DCGTerm ();|
    |if (elements != null)|
    |  for (int i = elements.Count-1; i >= 0; i--) term = new DCGTerm ((Term)elements [i], term);|
  ---


ROOT

  PrologCode

